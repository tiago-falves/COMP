options
{
 LOOKAHEAD=1;
}
PARSER_BEGIN(Javamm)

import java.util.ArrayList;
import symbols.*;

public class Javamm
{
    private ArrayList<SymbolsTable> symbolsTables = new ArrayList<SymbolsTable>();
    public static void main(String args[]) throws ParseException, java.io.FileNotFoundException {

        ParseException.resetWhileErrors();
        Javamm myJavamm = new Javamm(new java.io.FileInputStream(args[0]));
        SimpleNode root = myJavamm.JavaMM(); // returns reference to root node
        int errors = ParseException.getWhileErrors();
        if(errors > 0){
            throw new ParseException("Errors"); 
        }


        //System.out.println("Expression value: "+myJavamm.eval(root));

        root.dump(""); // prints the tree on the screen
    }
    public void setSymbolsTables(ArrayList<SymbolsTable> symbolsTables){
        this.symbolsTables = symbolsTables;
    }
}
PARSER_END(Javamm)

SKIP :
{                                   
" " | "\r" | "\t" | "\n"
|
<"//" (~["\n", "\r"])* ("\n" | "\r")>
|
<"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">
}

TOKEN: 
{
      < IMPORT : "import" > 
    | < PUBLIC : "public" >
    | < RETURN: "return" >
    | < CLASS: "class" >
    | < EXTENDS: "extends" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < WHILE: "while" > 
    | < STATIC: "static" >
    | < MAIN: "main" >
    
    //Brackets
    | < LEFTBRACKET : "{" >
    | < RIGHTBRACKET : "}" >
    | < SQUARERIGHTBRACKET : "]" >
    | < SQUARELEFTBRACKET : "[" >
    | < LEFTPARENTHESES : "(" >
    | < RIGHTPARENTHESES : ")" >
    | < COMMA : "," >
    | < DOT : "." >
    | < SEMICOLON : ";" >
    | < EQUAL: "=" >

    //Operations
    | < AND: "&&" >
    | < LESS: "<" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < MULT: "*" >
    | < DIV: "/" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < NEG: "!" >

    //Special
    | < THIS: "this" >
    | < NEW: "new" >
    | < LENGTH: "length" >

    //Types
    | < BOOLEAN: "boolean" >
    | < INT: "int" >
    | < STRING: "String" >
    | < VOID: "void" >

    // Java valid identifiers / literals
    | < IDENTIFIER : (["_", "$"])(["a"-"z", "A"-"Z", "0"-"9", "_", "$"])+ | ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9", "_", "$"])* >
    | < INTEGERLITERAL : ("0" | (["1"-"9"](["0"-"9"])*) | ("0x"(["0"-"9","a"-"f","A"-"F"])+) | ("0b"(["0","1"])+)) >
}

SimpleNode JavaMM() : {}
{
    (ImportDeclaration())* (ClassDeclaration())+ <EOF> {return jjtThis;} // Java code inside brackets
}

void ImportDeclaration() : {Token t;}
{
    <IMPORT> 
    [
        <STATIC> #Static
    ] 
    t=<IDENTIFIER>{jjtThis.jjtSetVal(t.image);} #Identifier 
    ImportDeclaration1()
}

void ImportDeclaration1() #void: {Token i;} 
{
    <DOT> #Dot
    i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #Identifier 
    ImportDeclaration1()
    | 
    [
        ImportArgs()
        [ TypeImport() ] #ReturnImport
    ]
    <SEMICOLON>
}

void ImportArgs() : {}
{
    <LEFTPARENTHESES>
    [ TypeImport() ImportDeclaration2() ] 
    <RIGHTPARENTHESES>
}

void ImportDeclaration2() #void: {}
{
    [
        <COMMA>
        TypeImport() ImportDeclaration2()
    ]
}

void TypeImport() #void: {Token t;}
{
    Type() | t=<VOID>{jjtThis.jjtSetVal(t.image);} #Type

}

void TypeVar(VariableDescriptor descriptor) #void: {Token t;}
{
    t=<BOOLEAN>{jjtThis.jjtSetVal(t.image);} #Type {descriptor.setType(Type.BOOLEAN);}
    | 
    t=<STRING>{jjtThis.jjtSetVal(t.image);} #Type {descriptor.setType(Type.STRING);}
    | 
    t=<INT> {descriptor.setType(Type.INT);}
    (
        <SQUARELEFTBRACKET> 
        <SQUARERIGHTBRACKET> 
        {jjtThis.jjtSetVal(t.image + "[]");} #Type
        |
        {jjtThis.jjtSetVal(t.image);} #Type
    )
}

void Type() #void: {Token t;}
{
    t=<BOOLEAN>{jjtThis.jjtSetVal(t.image);} #Type
    |
    t=<STRING>{jjtThis.jjtSetVal(t.image);} #Type
    |
    t=<INT>
    (
        <SQUARELEFTBRACKET>
        <SQUARERIGHTBRACKET>
        {jjtThis.jjtSetVal(t.image + "[]");} #Type
        |
        {jjtThis.jjtSetVal(t.image);} #Type
    )
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    (
        MethodHeader()
        <LEFTBRACKET>
            MethodBody()
        <RIGHTBRACKET>
        | MainDeclaration()   
    )
}

void MethodHeader() : {Token i;}
{
    {jjtThis.jjtSetVal("public");} #Modifier
    Type() i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #Identifier
    <LEFTPARENTHESES> 
        MethodArguments() 
    <RIGHTPARENTHESES> 
}

void MainArgs() : {Token s, i;}
{
    <LEFTPARENTHESES> 
    s=<STRING>{jjtThis.jjtSetVal(s.image+"[]");} #Type 
    <SQUARELEFTBRACKET>     
    <SQUARERIGHTBRACKET>
    i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #Identifier 
    <RIGHTPARENTHESES> 
}

void MainDeclaration() : {}
{
    <STATIC>
    <VOID>
    <MAIN>
        MainArgs()
        <LEFTBRACKET>
        VariableAndStatement()
        <RIGHTBRACKET>

}

void MethodArguments() : {Token i1, i2;}
{
    [Type()
    i1=<IDENTIFIER>{jjtThis.jjtSetVal(i1.image);} #Identifier{} 
    ( 
        <COMMA>
        Type()
        i2=<IDENTIFIER>{jjtThis.jjtSetVal(i2.image);} #Identifier
    )*]
}

void VarDeclaration(SymbolsTable table) #VariableDeclaration : {Token c, t; VariableDescriptor var;}
{
    {var = new VariableDescriptor();}
    (
        TypeVar(var) | c=<IDENTIFIER>{jjtThis.jjtSetVal(c.image);} #ClassType
    )
    t=<IDENTIFIER>{jjtThis.jjtSetVal(t.image);} #VariableName {var.setName(t.image);}
    <SEMICOLON>
    {table.addSymbol(var); System.out.println("ZASS");}
}

void VarDeclaration2() #VariableDeclaration : {Token i;}
{
    Type() 
    i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #VariableName 
    <SEMICOLON>
}

void VariableAndStatement() #void : {Token i1, i2;}
{
    VarDeclaration2()
    VariableAndStatement()
    |
    i1=<IDENTIFIER>{jjtThis.jjtSetVal(i1.image);} #Identifier{} 
    (
        i2=<IDENTIFIER>{jjtThis.jjtSetVal(i2.image);} #Identifier 
        <SEMICOLON>
        VariableAndStatement()
        |
        (
            (
                (
                    <EQUAL> #Equal 
                    Expression()
                )
                |
                (ArrAcc() [
                    <EQUAL> #Equal 
                    Expression()
                    ])
                |
                (ObjAcc() ExpressionTail())
                |
                (ExpressionTail())
            ) 
            <SEMICOLON>
        ) (Statement())*
    )
    |
    [LiteralStatement() (Statement())*]
}

void MethodBody() #void : {}
{
    VariableAndStatement() 
    <RETURN> #Return
    Expression() 
    <SEMICOLON>
}

void ClassDeclaration() #ClassDeclaration : {Token i1, i2; SymbolsTable classTable;}
{
    {classTable = new SymbolsTable();}
    {symbolsTables.add(classTable);}
    <CLASS> 
    i1=<IDENTIFIER>{jjtThis.jjtSetVal(i1.image);} #ClassName{}
    (
        <EXTENDS> #Extends
        i2=<IDENTIFIER>{jjtThis.jjtSetVal(i2.image);} #ClassName
    )* 

    <LEFTBRACKET>
        (VarDeclaration(classTable))*
        (MethodDeclaration())* 
    <RIGHTBRACKET>
}

void CommonStatement() #void: {}
{
    <LEFTBRACKET>
    (Statement())* 
    <RIGHTBRACKET> 
    | IfStatement() 
    | WhileStatement() 
}

void Statement() #void: {}
{
    CommonStatement()
    | LineStatement()
}

void LiteralStatement() #void : {}
{
    CommonStatement()
    | LiteralLineStatement()
}

void LineStatement() : {Token i;}
{
    (
        LiteralExpr4() ExpressionTail()
        |
        (
            i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #Identifier{} 
            (
                <EQUAL> #Equal 
                Expression()
                |
                (ArrAcc() [<EQUAL> #Equal Expression()])
                |
                (ObjAcc() ExpressionTail())
                |
                ExpressionTail()
            )
        )
    )
    <SEMICOLON>
}

void LiteralLineStatement() #void : {}
{
    LiteralExpr4() ExpressionTail()
    <SEMICOLON>
}

void ExpressionTail() #void : {}
{
    (Oper4())* (Oper3())* (Oper2())* (Oper1())*
}

void Statement1() #void : {}
{
    (
        <EQUAL> #Equal
        Expression() 
        <SEMICOLON> #Semicolon
    ) 
    | ( 
        ArrAcc()
        [
            <EQUAL> #Equal
            Expression() 
            <SEMICOLON> #Semicolon
        ])
    | ObjAcc()
}

void IfStatement() : {}
{
    <IF> 
    <LEFTPARENTHESES> 
    Expression() #IfExpression
    <RIGHTPARENTHESES>
    Statement()
    <ELSE> #Else
    Statement()
}

void WhileStatement() : {}
{
    try{
        <WHILE>
        <LEFTPARENTHESES> 
    }catch(ParseException e){
        
        int errors = ParseException.getWhileErrors();
        if(errors >= 10){
            throw new ParseException("Too many errors"); 
        }
        ParseException.countError(); 
        
        System.out.println(e.getImportantMessage());
        Token p = getToken(0);
        if (p.kind == WHILE)
            if (getToken(1).kind != LEFTPARENTHESES)
            System.out.println("Missing '(' on line "+p.beginLine+", column "+p.beginColumn+".\n");
    }

    try {
        Expression() #WhileExpression
        <RIGHTPARENTHESES> 
    }
    catch (ParseException e) {
        int errors = ParseException.getWhileErrors();
        if(errors >= 10){
            throw new ParseException("Too many errors"); 
        }
        ParseException.countError(); 

        System.out.println(e.getImportantMessage());
        Token p = getToken(0);
        System.out.println("Error in Expression inside while statement.\n");

        Token t;
        do {
            t = getToken(1);
            if(t.kind == LEFTBRACKET) {
                Token r = getToken(0);
                if (r.kind != RIGHTPARENTHESES)
                    System.out.println("Missing ')' on line "+r.beginLine+", column "+r.beginColumn+".\n");
                break;
            }
            else if (t.kind == RIGHTPARENTHESES && getToken(2).kind != RIGHTPARENTHESES) {
                getNextToken();
                break;
            }
            getNextToken();
        } while (true);        
    }

    Statement()
}

void Expression() #void : {} 
{
    Expr1() (Oper1())*
}

void Oper1() #void : {} 
{
    <AND> #And
    Expr1() 
}

void Expr1() #void : {}
{
    Expr2() (Oper2())*
}

void Oper2() #void : {}
{
    <LESS> #Less
    Expr2() 
}

void Expr2() #void : {}
{
    Expr3() (Oper3())*
}

void Oper3() #void : {}
{
    <PLUS> #Plus
    Expr3() |
    <MINUS> #Minus
    Expr3() 
}

void Expr3() #void : {}
{
    Expr4() (Oper4())*
}

void Oper4() #void : {}
{
    <MULT> #Mult
    Expr4() |
    <DIV> #Div
    Expr4() 
}

void Expr4() #void : {}
{
    LiteralExpr4() |
    IdentifierExpr4()
}

void LiteralExpr4() #void : {Token t;}
{
    (t=<INTEGERLITERAL>{jjtThis.jjtSetVal(t.image);} #IntegerLiteral{} 
        (ExprTail())*) |
    (<TRUE> #True{}
        (ExprTail())*) |
    (<FALSE> #False{} 
        (ExprTail())*) |
    (<THIS> #This{}
        (ExprTail())*) |
    (<NEW> #New
        NewExpr()) |
    (<LEFTPARENTHESES> #LeftParentheses
        Expression() 
        <RIGHTPARENTHESES> #RightParentheses{}
        (ExprTail())*) |
    (<NEG> #Negation 
        Expr4()) 
}

void IdentifierExpr4() #void : {Token t;}
{
    t=<IDENTIFIER>{jjtThis.jjtSetVal(t.image);} #Identifier{}
    (ExprTail())*
}

void ExprTail() #void : {}
{
    ArrAcc() | ObjAcc()
}
    
void ArrAcc() #Array : {}
{
    <SQUARELEFTBRACKET> 
    Expression() 
    <SQUARERIGHTBRACKET> 
}

void ObjAcc() #void : {}
{
    [
        <LEFTPARENTHESES> #LeftParentheses
        [
            Expression()
        ]
        <RIGHTPARENTHESES> #RightParentheses
    ]
    <DOT> #Dot
    ObjAccTail()
}

void ObjAccTail() #void : {Token t;}
{
    <LENGTH> #Length
    | 
    t=<IDENTIFIER>{jjtThis.jjtSetVal(t.image);} #Identifier 
    Arguments()
}

void Arguments() #Arguments : {} 
{
    <LEFTPARENTHESES>
    [Expression() #Argument [Argument()]]
    <RIGHTPARENTHESES> 
}

void Argument()  : {}
{
    <COMMA> 
    Expression() [Argument()]

}

void NewExpr() #void : {Token i;}
{
    i=<INT>{jjtThis.jjtSetVal(i.image);} #Type
    ArrAcc()
    |
    i=<IDENTIFIER>{jjtThis.jjtSetVal(i.image);} #Identifier
    <LEFTPARENTHESES> #LeftParentheses
    <RIGHTPARENTHESES> #RightParentheses
    [ObjAcc()]
}